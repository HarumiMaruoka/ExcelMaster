using System;
using System.Collections.Generic;
using System.Text;

namespace CsvToSource
{
    /// <summary>
    /// MasterMemory 用バイナリ生成クラスのソースコードを動的生成するジェネレータ。
    /// </summary>
    public static class MasterMemoryBinaryGenerator
    {
        /// <summary>
        /// バイナリ生成用クラスのソースコード文字列を生成。
        /// </summary>
        public static string Generate(IEnumerable<string> usingNamespaces = null, string @namespace = null, string buildClassName = null, string masterClassName = null)
        {
            if (string.IsNullOrWhiteSpace(@namespace)) throw new ArgumentException("namespace is required", nameof(@namespace));
            if (string.IsNullOrWhiteSpace(buildClassName)) throw new ArgumentException("buildClassName is required", nameof(buildClassName));
            if (string.IsNullOrWhiteSpace(masterClassName)) throw new ArgumentException("masterClassName is required", nameof(masterClassName));

            var binaryFileName = masterClassName + ".bytes";
            var outputRelativePath = $"Assets/Example/Binary/{binaryFileName}";

            var sb = new StringBuilder();

            void AppendIndented(int level, string text)
            {
                if (level > 0) sb.Append(new string(' ', level * 4));
                sb.AppendLine(text);
            }

            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine("using MasterMemory;");
            sb.AppendLine("using MessagePack;");
            sb.AppendLine("using MessagePack.Resolvers;");
            //追加の using (重複/空白/既存は除外)
            if (usingNamespaces != null)
            {
                var existing = new HashSet<string>(StringComparer.Ordinal)
                {
                    "System", "System.IO", "MasterMemory", "MessagePack", "MessagePack.Resolvers"
                };
                foreach (var ns in usingNamespaces)
                {
                    if (string.IsNullOrWhiteSpace(ns)) continue;
                    var trimmed = ns.Trim();
                    if (!existing.Add(trimmed)) continue; //既存 or 重複
                    sb.Append("using ").Append(trimmed).AppendLine(";");
                }
            }
            sb.AppendLine();
            AppendIndented(0, $"namespace {@namespace}");
            AppendIndented(0, "{");
            AppendIndented(1, $"internal static class {buildClassName}");
            AppendIndented(1, "{");
            AppendIndented(2, "/// <summary>");
            AppendIndented(2, $"/// {masterClassName} 配列から MasterMemory バイナリを生成し保存します。");
            AppendIndented(2, "/// </summary>");
            AppendIndented(2, $"/// <param name=\"masters\">{masterClassName} 配列</param>");
            AppendIndented(2, $"/// <param name=\"outputPath\">出力パス。未指定時 '{outputRelativePath}'。</param>");
            AppendIndented(2, "/// <returns>生成されたバイナリ</returns>");
            AppendIndented(2, $"public static byte[] Build({masterClassName}[] masters, string outputPath = null)");
            AppendIndented(2, "{");
            AppendIndented(3, "if (masters == null) throw new ArgumentNullException(nameof(masters));");
            AppendIndented(3, $"outputPath = string.IsNullOrWhiteSpace(outputPath) ? \"{outputRelativePath}\" : outputPath;");
            sb.AppendLine();
            AppendIndented(3, "var messagePackResolvers = CompositeResolver.Create(");
            AppendIndented(4, "MasterMemoryResolver.Instance,");
            AppendIndented(4, "StandardResolver.Instance");
            AppendIndented(3, ");");
            AppendIndented(3, "var options = MessagePackSerializerOptions.Standard.WithResolver(messagePackResolvers);");
            AppendIndented(3, "MessagePackSerializer.DefaultOptions = options;");
            sb.AppendLine();
            AppendIndented(3, "var builder = new DatabaseBuilder();");
            AppendIndented(3, "builder.Append(masters);");
            AppendIndented(3, "var binary = builder.Build();");
            sb.AppendLine();
            AppendIndented(3, "var dir = Path.GetDirectoryName(outputPath);");
            AppendIndented(3, "if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);");
            AppendIndented(3, "File.WriteAllBytes(outputPath, binary);");
            sb.AppendLine();
            AppendIndented(3, "return binary;");
            AppendIndented(2, "}");
            AppendIndented(1, "}");
            AppendIndented(0, "}");
            return sb.ToString();
        }
    }
}
